### HTTP

**(1) HTTP, HTTPS 프로토콜이란?**

​	HTTP는 클라이언트 서버 구조이며, 무상태 프로토콜 및 비연결성을 지니고 있습니다.

​    HTTPS는 HTTP에서 통신의 인증과 암호화를 위해 개발되었다. SSL이나 TLS프로토콜을 통해 세션 데이터를 암호화한다.

**(2) GET, POST 차이**

​	GET은 URL에 그대로 query의 이름과 값이 같이 연결되어 표현됩니다.

​	GET은 한번 요청시 전송 데이터 양은 주소값+파라미터로 255자(HTTP/1.1인 경우 2048자)로 제한됩니다.

​	POST는 query방식이 body안에 들어가 있어서 보안에 조금 유리함이 있습니다.

​	POST는 한번 요청시 데이터 양의 제한이 없습니다.

**(3) http 1.1 vs http 2.0 차이**

​	HTTP/1.1는 기본적으로 Connection당 하나의 요청을 처리 하도록 설계

​	동시 전송이 불가능하고 요청과 응답이 순차적으로 이뤄짐

​	특정 응답의 지연

​	RTT( Round Trip Time ) 증가

​	무거운 Header 구조 (특히 Cookie)

​	HTTPS는 HTTP가 유선 상에서 표현 방법을 대치 하는 것

​	Header Compression : HTTP 2.0에서는 Header에 중복값이 존재하는 경우 static/Dynamic Header Table 개념을 사용하여 중복 Header를 	출하고 중복된 Header는 index값만 전송하고 중복되지 않은 정보 값은 Huffman Encoding 기법으로 인코딩하여 전송한다.

​	Multiplexed Streams : 한 커넥션에 여러 개의 메시지를 동시에 주고 받을 수 있다.

​	Stream Prioritization : 요청 리소스간의 의존관계(우선순위)를 설정할 수 있다.

​	Server Push : HTTP 1.1는 HTML문서를 해석하기 위해 필요한 리소스를 재 요청할 수 있는데, HTTP 2.0에서는 재 요청없이 Server Push 기법을 활용하여 해석이 가능하다.

**(4) http 상태 코드 설명**

​	1xx - 서버가 요청을 수신하여 처리중

​	2xx - 요청이 성공적으로 수신되었으며 그에 따른 정보는 응답으로 나감

​	3xx - 요청을 완료하기 위해 추가 동작이 필요하다.

​	4xx - 클라이언트 에러로 서버가 요청 이해 불가능하다.

​	5xx - 서버에러로 서버가 요청 처리 실패

**(5) http vs https 차이점**

​	HTTP: 평문 데이터를 전송하는 프로토콜

​	HTTPS: 암호화가 추가된 프로토콜, 자신의 공개키를 갖는 인증서를 발급하여 보내는 메세지를 암호화하고 메세지는 개인키를 이용하여 복호화 함

**(6) 자바스크립트에서 HTTP request를 동기로 호출하고 값을 처리하면 발생하는 문제점은?**

​	request에 대한 리스폰스 응답 시간이 길어질 수 있기 때문..

**(7) Get 의 통신 방식과 용도**

​	DB에 추가로 정보를 처리하지 않고, 저장된 Data를 단순 요청하는 정도로 사용합니다.

​	GET은 Select와 비슷한 성향을 가지고 있습니다. 서버에서 어떤 데이터를 가져와서 보여줄 때 사용합니다. 즉, 서버의 어떤 값이나 내용, 상태 등을 바꾸	지 않는 경우에 사용합니다. 예를 들면, 조회같은 게시판에서 글의 내용에 대한 목록을 보여주는 경우나 글의 내용을 보는 경우입니다.

**(8) Post의 통신 방식과 용도**

​	클라이언트와 서버 간에 인코딩하여 서버로 전송합니다.

​	헤더를 통해 요청이 전송되는 방식입니다.

​	DB에 추가로 서버에서 갱신 작업을 할때, 서버에서 정보가 가공되어 응답하는 경우에 사용합니다.

​	POST는 서버의 값이나 상태를 바꾸기 위해서 사용됩니다. 글쓰기를 하면 글의 내용이 DB에 저장/수정시에 DB의 값이 변경하게되는 경우에 POST를 사	용합니다. 예를 들면, 게시판의 글을 써서 올리거나, 수정하는 경우입니다.

**(9) HTTPS 보안 방식은 무엇이며, 어떻게 작동하는지?**

​	클라이언트가 서버에 접속하면 서버는 인증서를 제공한다.

​	클라이언트는 해당 인증서가 CA(Certificate Authority 디지털 인증서를 제공하는 공인된 기업)리스트에 있는지, 해당 CA의 공개키로 인증서가 복호화 	되는지를 확인한다. 이를 통해 해당 서버의 신원을 확인한다.

​	서버와 클라이언트는 공개키를 통해 서로를 확인한다. 그리고 공개키를 통해 서보와 클라이언트가 암호화 한 데이타를 조합한 대칭키를 생성한다. 해당 값	은 세션으로 저장하여 이후 통신에 사용되는 데이타를 암호화/복호화한다.

**(10) GET, POST를 제외하고 다른 방식들은 무엇이 있나요?**

​	PUT, DELETE, PATCH, TRACE, OPTIONS

**(11) HTTP 매서드와 이것이 하는 역할에 대해 설명해주세요.**

​	GET - 클라이언트가 서버에 리소스를 요청할 때 사용(R) -> 멱등 o

​	POST - 클라이언트가 서버의 리소스를 새로 만들 때 사용(C) -> 멱등 x

​	PUT - 클라이언트가 서버의 리소스 수정할 때 사용(U - 전체 수정) -> 멱등 o

​	PATCH - 클라이언트가 서버의 리소스 수정할 때 사용(U - 일부 수정) -> 멱등 x

​	DELETE - 클라이언트가 서버의 리소스 삭제할 때 사용(D - 삭제) -> 멱등 x

**(12) 쿠키와 세션에 대해 설명해주세요.**

​	쿠키와 세션을 사용하는 이유는 HTTP 프로토콜의 약점을 보완하기 위해 사용합니다.

​	HTTP 환경에서 서버는 클라이언트가 누구인지 확인해야 합니다. 그 이유는 connectionless(비연결성), stateless(무상태 프로토콜)한 특성이 있기 때	문입니다.

​	쿠키와 세션은 위의 두 가지 특징을 해결하기 위해 사용합니다. 예를 들어, 쿠키와 세션을 사용하지 않으면 쇼핑몰에서 옷을 구매하려고 로그인을 했음에	도, 페이지를 이동할 때 마다 계속 로그인을 해야 합니다. 쿠키와 세션을 사용했을 경우, 한 번 로그인을 하면 어떠한 방식에 의해서 그 사용자에 대한 인증	을 유지하게 됩니다.

​	쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일입니다.

​	세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리합니다.

**(13) Restful API란**

​	링크 -> https://deview.kr/2017/schedule/212

**(14) RestFul API vs HTTP 통신 방법**

​	REST API는 HTTP API에 여러가지 제약 조건이 추가됩니다.

​	REST는 다음 4가지 제약조건을 만족해야 합니다.

​	자원의 식별, 메시지를 통한 리소스 조작, 자기서술적 메세지, 애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어

​	많은 사람들이 해당 조건을 지키지 않아도 REST API라고 하기 때문에, HTTP API나 REST API를 거의 같은 의미로 사용하고 있습니다. 하지만 앞서 말씀	드린 것 처럼 엄격하게 위의 내용들을 모두 지켜야 REST API라고 할 수 있습니다

**(15) Cookie, Session, Session Storage, Local Storage 중 어떤 것이 가장 효율적인가요?**

​	Cookie/Session: Cookie에 클라이언트에 대한 정보를 저장해뒀다가 사용하거나 Session을 등록해서 유지하는 방식

​	Session Storage/Local Storage: HTML5에서 제공, 세션 스토리지는 세션이 유지되고 있을 때 까지 브라우저 내부 저장소에 저장하고 세션이 끊기면 	자동으로 없어짐, 로컬 스토리지는 사용자나 프론트엔드 내부적으로 삭제를 하지 않는 이상 영구적으로 저장됨

**(16) SSL 설명**

​	http가 제 3자에게 조회 될 수 있는 것을 방지하기 위한 암호화 기술이다. CA를 통해 서버가 안전한지 클라이언트가 확인할 수 있고, 서버와 클라이언트가 	공개키와 대칭키를 활용하여 송수신하는 데이터를 제 3자가 복호화할 수 없도록 한다.

------

### 프로토콜

**(1) OSI 7 Layer에 대해 설명해보주세요.**

​	7계층은 왜 나눌까?

​	통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문이다.

1. 물리(Physical)

   리피터, 케이블, 허브 등

   단지 데이터 전기적인 신호로 변환해서 주고받는 기능을 진행하는 공간

   즉, 데이터를 전송하는 역할만 진행한다.

2. 데이터 링크(Data Link)

   브릿지, 스위치 등

   물리 계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할

   Mac 주소를 통해 통신한다. 프레임에 Mac 주소를 부여하고 에러검출, 재전송, 흐름제어를 진행한다.

3. 네트워크(Network)

   라우터, IP

   데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당한다.

   라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다.

   라우팅, 흐름 제어, 오류 제어, 세그먼테이션 등을 수행한다.

4. 전송(Transport)

   TCP, UDP

   TCP와 UDP 프로토콜을 통해 통신을 활성화한다. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공해준다.

   TCP : 신뢰성, 연결지향적

   UDP : 비신뢰성, 비연결성, 실시간

5. 세션(Session)

   API, Socket

   데이터가 통신하기 위한 논리적 연결을 담당한다. TCP/IP 세션을 만들고 없애는 책임을 지니고 있다.

6. 표현(Presentation)

   JPEG, MPEG 등

   데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당한다.

   파일 인코딩, 명령어를 포장, 압축, 암호화한다.

7. 응용(Application)

   HTTP, FTP, DNS 등

   최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.

   사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공한다.

**(2) TCP/IP 4계층에 대해 설명해주세요.**

​	4계층 응용 계층 (Application Layer)

​	OSI 7계층의 세션 계층, 표현 계층, 응용 계층에 해당한다.

​	TCP/UDP 기반의 응용 프로그램을 구현할 때 사용한다.

​	프로토콜 – FTP, HTTP, SSH

​	3계층 전송 계층 (Transport Layer)

​	OSI 7계층의 전송 계층(4계층)에 해당한다.

​	통신 노드 간의 연결을 제어하고, 신뢰성 있는 데이터 전송을 담당한다.

​	프로토콜 – TCP, UDP

​	2계층 인터넷 계층 (Internet Layer)

​	OSI 7계층의 네트워크 계층(3계층)에 해당한다.

​	통신 노드 간의 IP패킷을 전송하는 기능과 라우팅 기능을 담당한다.

​	프로토콜 – IP, ARP (ip->mac), RARP (mac->ip)

​	1계층 네트워크 액세스 계층 (Network Access Layer or Network Interface Layer)

​	OSI 7계층의 물리계층과 데이터 링크 계층 (1,2계층)에 해당한다.

​	물리적인 주소로 MAC을 사용한다.

​	LAN, 패킷망, 등에 사용된다.

**(3) tcp와 udp에 대해 설명해주세요.**

​	둘 모드 인터넷 상에서 데이터 전송을 위한 프로토콜이다.

**(4) TCP와 UCP의 특징과 차이점은**

​	**Tcp 특징**

​	연결형 서비스로 가상 회선 방식을 제공한다.

​	3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.

​	흐름 제어 및 혼잡 제어.

​	높은 신뢰성을 보장한다.

​	UDP보다 속도가 느리다.

​	전이중(Full-Duplex), 점대점(Point to Point) 방식.

​	**Udp 특징**

​	비연결형 서비스로 데이터그램 방식을 제공한다

​	정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.

​	UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다. 신뢰성이 낮다 TCP보다 속도가 빠르다

**(5) 3 way handshake**

​	가상회선을 수립하는 단계입니다. 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정입니다.

​		1. 클라이언트가 서버한테 SYN (접속요청) 을 하면

​    	2. 서버에서 응답을 합니다. SYN+ACK (접속요청과, 응답)을 같이 해줍니다.

​		3. 마지막으로 클라이언트에서 ACK (응답)을 합니다.

​	https://asfirstalways.tistory.com/356

**(6) 4 way handshake**

​	TCP연결을 해제하는 단계로, 클라이언트는 서버에게 연결해제를 통지하고 서버가 이를 확인하고 클라이언트에게 이를 받았음을 전송해주고 최종적으로 	연결이 해제됩니다. 단, 서버에서 소켓이 닫혔다고 통지해도 클라이언트 측에서는 일정시간 대기하는데, 혹시나 패킷이 나중에 도착할 수 있기 때문입니다.

**(7) dns에 대해 설명해주세요.**

​	호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발되었다. 특정 컴퓨터의 주소를 찾기 위해, 	사람이 이해하기 쉬운 도메인 이름을 숫자로 된 식별 번호로 변환해 준다

**(8) DNS round robin의 방식**

​	DNS를 이용해서 하나의 서비스에 여러 대의 서버를 분산시키는 방법

​	문제점은 서버의 수만큼 글러벌(공인ip) 주소가 필요합니다, 균등하게 분산되는 것은 아님, 서버 다운을 감지 못함

​	해결방안1 : AP서버에 Virtual IP를 부여해서 다중화를 구성한다. 각 AP서버를 Health check후 이상 감지되면 Virtual IP를 정상 AP서버로 인계하는 	방식을 사용 한다.

​	해결방안2 : Load Balancer를 도입한다.

**(9) state, stateless란?**

​	상태정보를 저장하는 것과 상태정보를 저장하지 않는 것이다.

참조 : [https://5equal0.tistory.com/entry/StatefulStateless-Stateful-vs-Stateless-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-HTTP-%EB%B0%8F-REST](https://5equal0.tistory.com/entry/StatefulStateless-Stateful-vs-Stateless-서비스와-HTTP-및-REST)

**(10) stateless 한계점**

​	state의 통신 구조의 한계점

​	Session의 한계 : 서버의 무리가 감

​	Sacle out의 문제 : 서버 확장이 어려움

​	플랫폼 다양화 : web, mobile 요청 처리 어려움

​	CSRF의 문제 : 세션 보안문제

​	CORS의 문제 : 도메인리소스 문제

​	REST API : StateLess 지향

**(11) ARP와 RARP 비교**

​	ARP는 통신을 원하는 호스트의 ip address를 알고 있을 때, 그 호스트의 mac 주소를 알고자 할 경우에 사용하는 프로토콜이다.

​	RARP는 ARP와 반대의 경우로 MAC주소를 이용하여 IP주소를 알고자 할 경우 사용 되어지는 프로토콜이다.

### 네트워크 기초

**브라우저 주소창에 [http://www.test.com](http://www.test.com/) 입력 후 엔터를 눌렀을 때 부터 페이지가 렌더링되는 과정을 상세히 설명하세요**

[**https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#%EC%9B%B9-%ED%86%B5%EC%8B%A0%EC%9D%98-%ED%81%B0-%ED%9D%90%EB%A6%84**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network#웹-통신의-큰-흐름)

**프록시 서버란?**

​	클라이언트가 프록시 서버를 통해 다른 네트워크 서비스에 간접적으로 접근을 할 수 있게 하는 것

​	프록시 서버는 요청된 내용을 캐시에 저장하고 다음에 같은 요청이 들어오면 캐시에 저장된 정보를 제공해 전송시간을 단축함

**패킷이란**

​	pack과 buckey의 합성어이먀, 예를들어 우체국에서 화물을 적당한 덩어리로 나눠 행선지를 표시하는 꼬리표를 붙이는데 데이터 조각이라고 생각하면 편	합니다

**cast의 종류**

​	Unicast: 1:1 통신, 원하는 대상 하나를 정해서 통신

​	Multicast: 1:N 통신, 원하는 대상 여러 명을 정해서 통신

​	Broadcast: 1:all 통신, 내 의지와 상관없이 무조건 받아들여야 하는 통신

**vpn이란**

​	VPN은 Virtual Private Network(가상 사설망)의 약자입니다. 이름에서 알 수 있듯이 VPN은 두 개 이상의 물리적 네트워크(또는 장치) 사이의 인터넷/	공용 네트워크를 통해 생성된 가상 네트워크로, 사용자/장치가 직접 연결된 하나의 개인 네트워크에 있는 것처럼 데이터를 보내고 받을 수 있도록 확장된 	개인 네트워크를 만듭니다. 따라서 VPN에 연결된 애플리케이션은 동일한 기능을 실행할 수 있고 개인 네트워크에 연결되어 있는 것처럼 관리할 수 있습니	다.

**네트워크 애플리케이션의 역할**

​	TCP/IP 소프트웨어에 데이터를 전달할 때, 데이터를 받을 호스트의 주소인 IP 주소와 포트번호도 함께 전달

​	IP주소: 네트워크에 연결된 기기를 식별하는 유일한 번호

​	포트 번호: 수신 측에서 동작하는 여러 애플리케이션 중 데이터를 수신할 애플리케이션을 식별하는 번호

**프록시 캐시에 대해 설명**

​	프록시에 다시 같은 리소스에 리퀘스트가 온 경우, 오리진 서버로부터 리소스를 획득하는 것이 아니라 캐시를 리스폰스로서 되돌려 주는 것

**비 연결성(Connectionless)에 대해 설명**

​	연결 설정이나 해제 과정이 없습니다. 예를들어 편지를 보낼 때 봉투에 상대방 주소만 적어서 보내면 목적지 주소만을 토대로 해당 목적지까지 배달 됩니	다.

**비 연결성의 단점(한계)와 극복을 어떻게 할까요?**

​	파일전송 같은 경우에는 파일은 연속된 데이터의 묶음이므로 만약 송신된 데이터가 중간에 분실되거나 순서가 바뀐다면 수신된 데이터는 원래의 데이터의 	묶음이 되지 못하고 파일은 정상적인 기능을 할 수 없다. 이럴때는 연결형 서비스를 사용해야함.

**CORS란**

​	Cross-Origin Resource Sharing(CORS)은 추가적인 HTTP header를 사용해서 애플리케이션이 다른 origin의 리소스에 접근할 수 있도록 하는 메	커니즘을 말합니다. 하지만 다른 origin에서 내 리소스에 함부로 접근하지 못하게 하기 위해 사용된다.

**로드밸런싱이란**

​	스케일 아웃시에 서버의 요청을 한 서버가 과도하게 받는 것을 방지하기 위해 작성된 알고리즘에 따라 요청을 균등하게 분배해주는 것

**비연결성을 해결하기 위한 방법**

​	Cookie/Session: Cookie에 클라이언트에 대한 정보를 저장해뒀다가 사용하거나 Session을 등록해서 유지하는 방식

​	Session Storage/Local Storage: HTML5에서 제공, 세션 스토리지는 세션이 유지되고 있을 때 까지 브라우저 내부 저장소에 저장하고 세션이 끊기면 	자동으로 없어짐, 로컬 스토리지는 사용자나 프론트엔드 내부적으로 삭제를 하지 않는 이상 영구적으로 저장됨

**페이지의 내용과 데이터의 값이 계속해서 바뀌면**

​	캐시의 만료기간을 짧게 한다.