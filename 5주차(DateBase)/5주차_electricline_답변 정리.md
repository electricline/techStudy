## 데이터베이스

- 데이터베이스란?

  데이터베이스란 여러 사람들이 공유할 목적으로 체계화해 통합하고 관리하는 데이터의 집합이다. CRUD를 할 수 있습니다.

- DBMS란?

  DBMS란 데이터베이스를 활용하기 위한 소프트웨어 시스템이며 종류로는 Oracle, MySQL, PostgreSQL 등이 있습니다.

- RDBMS란?

  2차원의 테이블 형태로 데이터를 표시하는 데이터베이스입니다.  테이블은 로우와 컬럼으로 나누 상호 관련성을 가진 데이터끼리 테이블을 이룹니다. 확장에 용이합니다. ACID!

- NOSQL란?

  Not Only SQL의 줄임말입니다. 기존의 RDB보다 더 융통성 있는 확장이 가하고 데이터의 저장 및 검색에 더 특화되어 있습니다. 그 이유는 단순 검색에 특화된 Key -Value 저장 방법을 이용하기 때문입니다.  

- NOSQL을 사용하는 이유는 무엇인가요?

  NoSQL은 초고용량 데이터 처리 등 성능에 특화된 목적을 위해, 비관계형 데이터 저장소에, 비구조적인 데이터를 저장하기 위한 분산 저장 시스템이라고 볼 수 있습니다.

  \- 관계형 모델을 사용하지 않으며 테이블간의 조인 기능 없음
  \- 직접 프로그래밍을 하는 등의 비SQL 인터페이스를 통한 데이터 액세스
  \- 대부분 여러 대의 데이터베이스 서버를 묶어서(클러스터링) 하나의 데이터베이스를 구성
  \- 관계형 데이터베이스에서는 지원하는 Data처리 완결성(Transaction ACID 지원) 미보장
  \- 데이터의 스키마와 속성들을 다양하게 수용 및 동적 정의 (Schema-less)
  \- 데이터베이스의 중단 없는 서비스와 자동 복구 기능지원
  \- 다수가 Open Source로 제공
  \- 확장성, 가용성, 높은 성능

  출처 : https://www.samsungsds.com/kr/insights/1232564_4627.html

- RDBMS와 NOSQL 비교

  RDBMS는 관계형 데이터베이스로 핵심적인 특징이 두가지 있습니다.

  1. 데이터는 **정해진 데이터 스키마에 따라 테이블에 저장**된다.
  2. 데이터는 **관계를 통해 여러 테이블에 분산**된다.

  데이터의 중복을 피하기 위해 관계를 활용하며 테이블을 생성할 때 만든 조건에 부합하지 않는 데이터는 저장할 수 없습니다.

  즉, 테이블간의 관계를 정의하여 데이터의 중복을 줄일 수 있습니다.

  

  NoSQL은 관계형 데이터베이스와 다르게 관계를 지니지 않습니다.

  또한 스키마도 없습니다.

  RDB에서는 정해진 조건에 부합하지 않으면 데이터를 추가하는것이 불가능했지만, NoSQL에는 그런 제약 조건이 없으므로 중복된 데이터를 저장할 수 있습니다. 그러므로 데이터 중복의 위험성이 존재합니다. 또한 NoSQL은 관계를 가지지 않으므로 당연히 조인 연산도 불가능합니다.

  따라서 조인을 할 필요성이 없고 중복된 데이터를 사용하지 않을 때 NoSQL을 쓰면 효과적입니다.

  

  **확장에서의 차이**

  두 데이터베이스에서는 Scaling 개념도 중요합니다.

  데이터베이스에서 확장은 수직적 확장과 수평적 확장이 있습니다.

  수직적 확장은 단순히 데이터베이스의 하드웨어 성능을 높여 처리력을 높이는 것입니다.

  수평적 확장은 더 많은 데이터베이스를 추가하여 요청이 분산되도록 처리하는 것입니다.

  NoSQL에서 수평적 확장에 RDB보다 훨씬 유리합니다.

  

  **RDB의 장점**

  - 명확하게 정의된 스키마로 데이터 무결성을 보장합니다.
  - 관계로 인해 각 데이터의 중복을 방지합니다.

  **RDB의 단점**

  - 유연하지 못합니다. (스키마를 설계하고 추후 수정하는 것도 힘들다.)
  - 조인 연산으로 인해 복잡한 쿼리 + 연산 처리량 증가
  - 대체로 수직적인 확장만 가능(스케일 업)

  **NoSQL 장점**

  - 스키마가 없어 유연함.
  - 데이터를 읽어 오는 속도가 빠르다.(키 - 벨류)
  - 스케일 업과 스케일 아웃 모두 유연하게 가능하다

  **NoSQL 단점**

  - 유연성으로 인해 데이터 구조 의사결정이 쉽지 않다.
  - 데이터의 중복을 업데이트 해줘야 한다.
  - 데이터가 만약 여러 곳에 중복되어 저장되어 있다면 수정시에 동기화가 반드시 필요하므로 처리량이 증가한다.

  **결론**

  관계를 맺고 있는 데이터가 자주 변경된다면 또는 변경될 여지가 없는 명확한 스키마 정의가 되어 있으며 데이터의 무결성이 중요한 경우에는 RDB를 이용합시다. 그러나 정확한 데이터 구조를 당장 정의할 수 없거나 변경/확장의 유연함이 필요한 경우, 읽기를 자주하며 데이터의 변경이 자주 일어나지 않는 경우, 데이터베이스의 스케일 아웃이 필요한 경우(막대한 양의 데이터를 다뤄야 한다.)에는 NoSQL을 이용합시다.

- DDL/DML/DCL/TCL이란?

  DDL은 데이터 정의어로 CREATE, ALTER, DROP 등이 있으며 테이블과 같은 스키마 구조를 정의하는데 사용합니다.

  DML은 데이터 조작어로 Select, Update, Insert, Delete 등으로 데이터를 조작하기 위한 CRUD 명령어 입니다.

  DCL은 데이터 제어어로 GRANT, REVOKE가 있으며 디비 접근 권한을 주고 회수하는 명령어 입니다.

  TCL은 트랜잭션 제어어로 COMMIT, ROLLBACK 등으로 논리적인 작업의 단위를 묶어서 DML에 의해 조작된 결과를 트랜잭션 별로 제어하는 명령어 입니다.

- DB의 데이타 유형은 무엇이 있나요? 
  오라클 기준으로 char, varchar, varchar2, date 타입 등이 있습니다.

- 인덱스란?

  인덱스란 RDB에서 검색을 빠르게 하기 위한 방식입니다. 책앞의 목차처럼 많이 비유되어 인덱스를 기준으로 검색하게 되면 보다 빠르게 쿼리에 작성된 내역을 찾을 수 있습니다.

- 인덱스를 사용하는 이유 및 장단점

  인덱스를 사용하게 되면 쿼리의 실행계획에 영향을 미치게 됩니다. 인덱스를 만들어 놓게 되면 또 다른 인덱스 테이블이 생성되어 그 안에 테이블의 주소 정보를 인덱스의 키 값과 함께 저장합니다. 그래서 만약 인덱스가 지정된 컬럼을 통해 검색하게 될 경우 인덱스 테이블에 접근하여 빠르게 테이블에 접근할 수 있습니다. 반면에 인덱스가 지정되어 있지 않다면 table full scan을 하게 될 것입니다.

  하지만 단점이라면 인덱스는 항상 정렬된 상태를 유지하여 데이터의 변경작업이 자주 일어난다면 인덱스를 재작성해야 하므로 오버헤드가 발생합니다. 그러므로 인덱스된 컬럼을 추가 또는 삭제 할 때 성능이 떨어집니다. 또한, 인덱스를 저장하는 장소가 필요하여 추가적인 공간이 필요합니다. 

- 클러스터드 인덱스 vs 논 클러스터드 인덱스

- 데이터베이스 인덱스의 자료구조

  

- 정규화란?

  관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 좀 더 구체적으로는 불만족스러운 **나쁜** 릴레이션의 애트리뷰트들을 나누어서 **좋은** 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게 된다. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, … 등이 존재한다.

- 정규화를 하는 이유는 무엇인가?

  한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 `갱신 이상`이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다. 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다.

- 정규화 1, 2, 3에 대하여 각각 설명하세요.

  출처 :  https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#정규화에-대해서

- 역정규화를 하는 이유는 무엇인가요

  역정규화는 이전에 정규화된 데이터베이스에서 성능을 개선하기 위해 사용되는 전략이다. 컴퓨팅에서 역정규화는 일부 쓰기 성능의 손실을 감수하고 데이터를 묶거나 데이터의 복제 사본을 추가함으로써 데이터베이스의 읽기 성능을 개선하려고 시도하는 과정

- DB 무결성이란?

  무결성이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미합니다.

- 무결성 유지하는 이유가 있을까요? 

  데이터의 정확성과 일관성을 보증하기 위해서입니다.

- 트랜잭션이란?

  데이터베이스에서 수행되는 작업의 논리적인 단위

- 트랜잭션의 성질을 말씀해보시오

  ACID

- ACID란?

  A - 원자성 : 트랜잭션의 수행 결과가 데이터베이스에 모두 반영되거나 모두 반영되지 않아야 합니다.(All or Nothing)

  C - 일관성 : 트랜잭션의 수행 결과는 항상 일관성이 있어야 합니다.

   I - 독립성 : 하나의 트랜잭션이 수행 중인 상황에서 다른 트랜잭션이 수행중인 연산에 끼어들 수 없음을 의미합니다.

  D - 지속성 : 트랜잭션이 성공적으로 완료되었다면 그 결과는 영구적으로 반영되어야 합니다.

- 트랜잭션을 병행으로 처리하려고 할 때 발생할 수 있는 문제를 설명하시오

  트랜잭션이 같은 데이터에 접근하려고 시도할 경우 데드락이 발생할 수 있습니다.

- 트랜잭션을 병행으로 처리할 때 문제를 방지하기 위한 방법을 설명하시오

  트랜잭션의 실행 순서를 일관적으로 지정하여 데이터에 접근하는 트랜잭션의 실행 순서를 유지시켜 데드락을 방지해야 합니다.

- 로킹 제어가 일으킬 수 있는 문제점은 무엇인가요?

  로킹 제어란 하나의 트랜잭션이 데이터에 접근하는 동안 다른 트랜잭션이 그 데이터의 항목을 접근할 수 없도록 잠그는 것을 의미합니다.

  로킹으로 인해 특정 세션이 작업을 진행하지 못하는 상태가 될 수 있어 블로킹 문제가 발생할 수 있습니다. 또는 두 세션이 각각 락을 설정하여 리소스를 기다리는 상황으로 인해 데드락이 발생할 수 있습니다.

- 트랜잭션 격리레벨에 대해 말해주세요

  Read Uncommitted -> 트랜잭션의 변경 내용이 커밋 또는 롤백과 관계 없이 다른 트랜잭션에서 보여집니다.. 그러므로 더티 리드가 발생합니다.

  Read committed -> 어떤 트랜잭션의 변경 내용이 커밋되어야만 다른 트랜잭션에서 접근할 수 있습니다. 더티리드는 발생하지 않습니다. - oracle

  Repetable Read -> 트랜잭션이 수행되기 전에 커밋된 내용에 대해서만 조회할 수 있습니다.  - mysql

  Serializable -> 가장 단순하며 엄격한 격리 수준으로 조회에 대해서도 로킹 기법을 사용한다.(보통 순수한 select문은 잠금을 걸지 않는다.)

- DB의 Commit / Rollback이란? 

  트랜잭션의 결과를 반영하는 것과 반영하지 않고 이전의 상태로 되돌리는 것을 말합니다.

- 참조 무결성이란?

  참조 무결성은 관계 데이터베이스 관계 모델에서 2개의 관련 있던 관계 변수 간의 일관성을 말합니다.

- 기본키(Primary Key)와 유일키(Unique Key)의 차이점?

  기본키가 더 작은 집합입니다. 기본키는 테이블 당 한개만 존재할 수 있으며 각 행을 구분하는 역할을 합니다. 필수적으로 unique 속성과 Not null 속성이 들어가며 유일키의 경우에는 단순히 유니크한 값을 갖는 속성을 가지게 합니다.

- SQL이란?

  RDB를 다루는 언어

- PK, FK란?

  pk는 기본키로 테이블 당 한개만 존재할 수 있으며 각 행을 구분하는 역할을 합니다. 기본적으로 Unique하며 not null 합니다.

  fk는 다른 테이블과 서로 연결되는데 사용합니다. 외래 키 값은 부모 테이블의 기본키 값과 동일해야 합니다.

- JOIN이란?

  2개의 테이블에서 공통된 컬럼을 이용하여 조합하는 방법

- JOIN의 원리는?

  join의 원리는 https://eehoeskrap.tistory.com/84 

- JOIN을 사용하는 이유는 무엇인가요?

  RDB에서는 데이터의 중복을 피하기 위해 관계를 토대로 테이블을 나누어 데이터를 저장합니다. 이때 필요한 데이터를 찾기 위해 조인 연산을 이용합니다.

- 테이블을 드롭(DROP)하는 것과 자르는 것(Truncate), 그리고 테이블 내 모든 레코드를 삭제(Delete)하는 것의 차이점은 무엇입니까?

  테이블을 드롭하는 것은 테이블의 스키마를 삭제하는 것입니다.

  truncate는 모든 전체 데이터를 삭제하며 롤백할 수 없습니다 그러므로 롤백할 수 있는 딜리트보다 빠르게 수행됩니다.

  딜리트는 일부 행만 where 조건을 통해 삭제 가능하며 롤백 가능합니다.

- 힌트란?

  SQL 튜닝의 핵심부분으로 일종의 지시구문이다. SQL에 포함되어 쓰여져 Optimizer의 실행 계획을 원하는 대로 바꿀 수 있게 해줍니다.

- 트리거란?

  테이블에 대한 이벤트에 반응해 자동으로 실행되는 작업을 말합니다.

- 프로시저란?

  쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합입니다.

- 실행계획이란?

  사용자가 질의한 SQL 문에 대해 최적의 실행 방법을 결정하는 역할을 옵티마이저가 수행합니다.

  이러한 최적의 실행 방법을 실행계획(Execution Plan)이라고 합니다.

- 데이타베이스 버퍼 캐시란?

  \- 사용자가 입력한 데이터를 데이터 파일에 저장하고 이를 다시 읽는 과정에서 거쳐가는 캐시영역

  \- 물리적인 I/O를 최소화하기 위해 최근에 사용한 블록에 대한 정보를 저장하는 메모리의 일정 영역

- 그룹별 순번, 순위기 매기기 함수란?

- 번외 질문 : DB 구조 설계해본 경험과 유의사항에 대해 말해주세요

- 검색조건중에 like절과 in 중에 어떤게 더 빠를까요? 그 이유는? (메가존 면접문제)

  Like의 검색 조건중 %가 앞에 있따면 인덱스를 타지 않습니다.

  그러나 만약 인덱스를 타게 된다면 in의 경우 서브쿼리의 결과 값을 메인 쿼리에 대입하여 조건 비교 후 결과를 출력하므로 라이크가 더 빠를 것 같습니다.

- 쿼리 순서에 대해 나열해주세요.

  from -> where -> group by -> havging -> select -> order by 

