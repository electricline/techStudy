자바 기술면접 준비

## JVM에대해서 GC의 원리

## 1-1 JVM에 대해 설명해 주시겠어요?
     - Java Virtual Machine(자바 가상 머신) 약자의 줄임말
     - 자바 애플리케이션을 클래스로더를 통해 읽어 들여 자바 API와 함께 메모리, gc등을 실행합니다.
   
## 1-2 JVM 메모리 구조에 대해서 설명
     - 메모리의 공간은 크게 'Static(스태틱) 영역', 'Stack(스택) 영역', 'Heap(힙) 영역'으로 구분되고 데이터타입(자료형)에 따라서 해당 공간에 할당 된다.
     - 클래스로드가 끝난 후 JVM은 main 메소드를 찾아 지역변수, 객체변수, 참조변수를 스택에 쌓음
   
## 1-3 자바프로그램 실행과정에 대해 설명 해 주세요
     - 자바 컴파일러(javac)가 자바 소스코드(.java)를 자바 바이트코드(.class)로 변환하고 
       Class Loader를 통해 JVM으로 로딩하고 Execution engine을 통해 해석하여 Runtime Data Areas에 배치되어 실질적인 수행
   
## 1-4 JVM 구성은 어떻게 되어 있나요?
    * Class Loader(클래스 로더)
   
    * Execution Engine(실행 엔진)
    > 자바 바이트 코드를 명령어 단위로 읽어서 실행한다.
   
    * Interpreter(인터프리터)
    > 한줄 씩 수행하는 방식.
   
    * JIT(Just In Time)
    > 인터프리터 방식의 단점을 보완하기 위해 도입된 JIT 컴파일러이다.
   
    * JIT가 어떻게 이용되는지??
    > 전체바이트 코드를 네이티브 코드로 변경하여 실행 성능을 높이는 방식
      
## Gc(가비지 컬렉터)
      
      * Gc란? 
         - 가비지 컬렉션의 약자이며, JVM의 Heap영역에서 사용하지 않는 객체를 삭제하는 프로세스를 말합니다.

      * 힙영역에는 뭐가 보통 들어가있나요?
         - Object타입의 String, List 같은 우리가 만든 "커스텀 클래스"들이 들어갑니다.

      * 그러면 GC는 어떻게 삭제할 객체가 아닌 객체를 구분할 수있는 걸까요?
         - GC루트로 부터 각각 참조하고 있는 객체들을 하나씩 하나씩 탐색해 나갑니다.

      * 참조된 객체들을 Reachable(리처블), 참조되지 않은객체는 UnReachable(언리처블)하다고 표현합니다.

      * GC 루트가 될수있는 조건
        1. Stack에 있는 지역변수나 파라미터들
        2. Method영역의 static 데이터들
        3. 자바 네이티브메서드 인터페이스(JNI)에 의해 생성된 객체들
   
      * GC 수거 대상
         - 참조되지 않은객체 (UnReachable)이 수거 대상입니다.
      
      * GC 동작 순서
         - 한 사이클과정은 Mark and Sweep으로 돌아가며, 어쩔때는 compact상황까지 돌아갑니다.
         
      * GC는 언제 일어날까요?
         - Heap 영역 : Young Generaion, Old Generation
         - Young Generaion (새로운 객체들이 할당되는 영역) -> 에덴 영역과 서바이벌 2개영역으로 총 3개의 영역이 존재합니다.
                                        -> Survivor가 다 쌓이면 다른 Survivor로 이동하고 하나는 빈상태로 변경합니다. 
                                        -> 이과정을 반복 후 살아있으면 Old영역으로 이동합니다.
                                       
         - Old Generation (Young Generaion에서 오랫동안 살아남은 객체들이 존재하는 영역)
         - MetaSpace는 heap에 있는건 아니고 가비지 컬렉션에 필요한 클래스메소드의 요약정보가 존재하는 영역

         -> 즉, Old Generation이 꽉차면 Major GC가 일어납니다.   
      
      * GC 과정에 대해 설명해주세요.
        1. 가비지 컬렉터가 스택의 모든변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
        2. Reachable Object가 참조하고 있는 객체도 찾아서 마킹한다.
        3. 마킹되지 않은 객체를 Heap에서 제거한다.   

      * JVM에서 메모리의 누수가 발생할까?
         - JVM에서도 메모리 누수가 발생할 수 있다. GC는 참조하지 않는 Unreachable한 객체를 제거 대상으로 간주하기 때문에 사용은 하지 않지만 계속해서 참조를 
           하는 경우가 있다면 메모리 누수가 발생할 수 있다. 
      
      * GC를 직접 수행할 수 있을까?
        GC는 System.gc() 메소드를 통해 개발자가 의도적으로 실행이 가능하다. 하지만 Stop-the-world 가 발생할 수 있어 시스템의 성능을 오히려 저하시킬 수 있다.
   
## 2. Collection (컬렉션)

   2-1 List, Set, Map의 차이는 무엇인가요?
      - 리스트(List) : 순서를 가지고 있으며, 데이터의 중복을 허용하는 보관 구조입니다.
      - 세트(Set) :  순서를 가지지 않고, 데이터의 중복을 허용하지 않는 구조입니다.
      - 맵(Map) : 키와 값을 가지며, 키를 가지고 원하는 데이터를 검색하는 구조

   2-2 List, Set, Map은 어떤 인터페이스를 구현하나요?
      - List, Set은 각각 Collection인터페이스를 구현한다. Map은 별도로 정의합니다.

   2-3 forEach를 사용할 수 있는 자료구조는 어떠한 인터페이스를 상속받고 있나요?
      - Iterable 인터페이스를 구현한다.

   forEach를 사용하면 다음 데이터를 얻기위해서 내부적으로 호출되는 메서드가 있는데 무엇일까요?
      - iterator() 메소드를 호출합니다.

   Iterator와 Iterable의 차이는 무엇인가요?
      - iterator은 순회할 수 있는 컬렉션을 의미한다. iterable 인터페이스를 implement하면 객체는 foreach문을 사용할 수 있습니다.

   * Iterator에서 구현해야 하는 메서드는 어떤것들이 있나요?
      - ????
      
   배열은 size가 변경될 수 있나요?
      - 처음 만들 때 크기를 고정해주어야 한다.
      - 접근하려면 반드시 인덱스 번호를 알아야 한다.
      - 항상 배열 안의 범위에서 인덱스 번호로 접근해야만 한다.

   <배열>
   Array 장점 : 엑세스가 빠르다. 
        단점 : 늘거나 줄지 못한다. 메모리를 차지하고 있다. (즉 가변성이 없다)

   <리스트>
   List는 갯수를 안만들어도 되서 좋다.
   List는 장점 : Array와 반대로 늘거나 줄어든다. 가변적이기 때문에, 메모리를 효율적으로 사용할수 있다.
         단점 : 엑세스가 느리다.

   <맵>
   장점 : 엑세스가 빠르면서(배열), 늘어나거나 줄어들수 있다(리스트)
   단점 : 메모리를 많이 쓴다. o(1)

   동적(가변) 자료구조는 무엇이 있을까요?
      - 가변은 List, Map, Set이 있고, 정적 자료구조는 Array로 구분됩니다.

   면접 질문중에 이런게 있었습니다.
   Array와 ArrayList랑 아애 다르다 ArrayList는 배열이 아니다. 떨어져있는 리스트를 연결노드해서 쉽게 찾는걸 링크드 리스트 양쪽방향한게 더블링크드리스트
   방금처럼 size가 1000인 배열을 만들었는데, 그 배열에 20개를 넣거나 5개로 줄이려면 어떻게 해야 하나요?
   - 늘리거나 줄일순 없지만, 갯수가 가변적이면 List를 사용하면 좋을것같습니다. 
   배열은 새로운 배열을 만들어서 복사해놓고 기존 배열은 지워야 합니다라고 이해하면 될까요?. ok.
   
   * ArrayList 와 LinkedList의 차이점
     - 둘 모두 리스트 인터페이스를 구현한 것은 동일하지만 어레이리스트의 경우 원소가 배열인 반면에 링크드리스트의 원소는 노드이다. 
      또한 get method에서 linkedList의 시간복잡도는 O(n)이며 삽입과 삭제의 경우 O(1)이다.
   
   * 그렇다면 배열을 이용하여 구현한 ArrayList의 단점은 무엇이 있을까요?
   
   * ArrayList의 remove 연산에 대해서도 말해주세요.   
   
   
   * 자바로 동적배열을 생성하고싶다면...
      - 자바의 배열은 동적할당되지않으므로 동적할당이 필요할 때 연결리스트 사용합니다.
   
   * 스택,힙 영역의 차이는? (프로세스 설명)
   운영체제가 프로그램에 할당해주는 메모리공간은 크게 code, data, heap, stack영역으로 나뉘게 됩니다.
   code영역에는 우리가 사용하는 code가, data영역에는 전역변수와 static변수, stack에는 지역변수 및 매개변수가 할당되며 heap에는 동적할당으로 할당된 메모리가 들어가게 됩니다.   
   
   * stack, heap 영역별로 무엇이 저장되는지 (참고 영상: [10분 테코톡] 🎅무민의 JVM Stack & Heap) 영역별로 설명
   -> Heap은 프로그램을 실행 하면서 생성한 모든 객체 인스턴스를 heap에 저장
   -> stack은 스레드별로 1개만 존재하고, 스택 프레임은 메서드가 호출될 때마다 생성된다. 메서드 실행이 끝나면 스택 프레임은 pop 되어 스택에서 제거된다.
   
   
   스택 프레임(Stack Frame)
   - 메서드가 호출될 때마다 새로 생겨 스택에 push 된다.
   - 스택 프레임은 Local variables array, Operand stack, Frame Data를 갖는다.
   - Frame Data는 Constant Pool, 이전 스택 프레임에 대한 정보, 현재 메서드가 속한 클래스/객체에 대한 참조 등의 정보를 갖는다.

   네이티브 메서드 스택(Native Method stack)
   - 자바 바이트코드가 아닌 다른 언어로 작성된 메서드를 의미합니다.
   
   Queue와 Stack을 이용하는 것과 배열이나 List를 이용하는 것과 무슨 차이가 있나요?
   - 
   
   Queue를 이용해 선입선출하는 메시지발송을 만들고 있는데, 
   만약에 긴급발송건이나 예약발송건이 있으면 먼저 보내줘야 합니다.
   어떤 자료구조를 이용하는 것이 좋을까요? -> 
   PriorityQueue(우선순위큐) Comparator 방식으로 구현 합니다.

   
   * tree는 어떤 경우에 사용을 하나요? 다른 자료구조랑 어떤 차이가 있나요? 어떤경우에 사용하는 것이 좋나요?
     -> 트리는 부모는 여러 자식을 가질 수 있지만 자식은 하나의 부모를 갖는 구조 입니다.
     -> 또한 큐와 스택같은 선형구조는 자료를 저장하고 꺼내는것에 초점이 맞춰져 있다면, 비선형구조인 트리는 계층적인 구조 표현에 초점이 맞춰져 있습니다.

   * B-Tree에 대해 설명할 수 있나요? 노드가 어떻게 되어있나요? 이진트리는 내부적으로 데이터가 어떻게 저장되나요?
     -> balanced tree(밸런스드 트리)중에 하나이며 balanced tree는 요소가 삽입될 때와 빠질 때 모든 leaf 노드가 비슷한 높이에 있도록 구조를 바꿉니다. 항상 일정한 검색 속도를 위해서 입니다.
     -> child가 꽉 찼을 때 child 를 늘릴 필요가 생기면 둘로 나누고, 인접 node 랑 비교했을 때 둘이 합쳐도 child 숫자가 반이 안되면 인접노드랑 합쳐집니다.

   * 이진검색트리(Binary Search Tree)에 대해 설명할 수 있나요?
     -> 이진탐색(O(LogN) + 연결리스트(O(1))의 장점을 가진것이 이진탐색트리입니다.
     -> 각 노드의 자식이 2개 이하인 트리입니다.
     -> 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큽니다.

   * B-Tree와 이진검색트리는 내부적으로 어떤 차이가 있나요? 데이터가 어떻게 저장되나요?
     -> B-tree는 비 종단 노드가 가질 수 있는 자식 노드으ㅢ 최대 수는 M입니다. 여기서 M은 B- 트리의 순서입니다.
       반면 이진트리는 최대 두 개의 하위 트리 또는 하위 노드를 가질 수 있습니다.

   * 이진검색트리에서 검색속도가 가장 느린케이스는 데이터가 어떻게 저장되어 있는 경우인가요?

   * 완전 이진 트리(Complete Binary Tree)에 대해 설명할 수 있나요?
     -> 이진 트리의 노드를 생성할 때 트리의 왼쪽부터 차곡차곡 채워 나가는 트리를 의미한다.
     -> 이때 완전 이진 트리의 한 레벨이 꽉 차기 전에는 다음 레벨에 노드를 생성할 수 없다. 즉, 마지막 레벨을 제외한 모든 레벨에는 노드가 꽉 차 있어야 한다는 뜻이다.

   * Queue와 Stack의 차이를 설명해줄수있나요?
     -> 큐는 선입선출, 스택은 후입선출

   * Queue와 Stack을 사용하는 예를 들어주세요.
     -> 스택은 다음과 같이 방금 닦은 접시를 항상 접시 더미 맨 위에 올려놓게 되고, 접시가 필요하면 맨 위에 있는 접시를 꺼내게 되는 스택과 같은 구조를 가지고 있습니다.
     -> 큐는 편의점 알바를 해보신 분들은 아시겠지만, 물품을 진열할 때 앞에서부터 채워 넣기 때문에 편의점 알바 경험이 있으신 분들은 선입선출에 대해 익숙할 것입니다.

   * Queue와 Stack은 내부적으로 어떤 자료구조를 사용하는지 알고 있나요?
   
   * 만약에 인스턴스 메시지를 등록된 순서대로 발송한다고 하면 어떤 자료구조를 이용하는 것이 좋을까요?
   -> java.util.Queue 인터페이스는 java.util.Deque 하위 인터페이스에 의해 확장됩니다. 
        Deque는 양방향 대기열을 만듭니다. 
        일반 대기열에서는 뒤쪽에 삽입하고 앞쪽에 제거 만 허용하는 반면, 데크를 사용하면 앞뒤 모두에서 삽입 또는 제거가 가능합니다. 
        deque는 앞뒤로 또는 한 번에 둘 다 사용할 수있는 대기열과 같습니다. 또한 순방향 및 역방향 반복자를 모두 생성 할 수 있습니다. 
        Deque 인터페이스는 java.util.ArrayDeque 및 java.util.LinkedList에 의해 구현됩니다.
   
## 3. Annotation (어노테이션)
   - 주석이라는 뜻으로, 인터페이스를 기반으로 한 문법 입니다. 주석과 의 그역할이 다르지만, 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다.
   - 또한 해석되는 시점을 정할 수도 있습니다.
   
## 4. Generic (제네릭)
   - 컴파일 과정에서 타입체크를 해주는 기능입니다.

   Generic(제네릭) 타입의 자료구조와 None Generic(비제네릭)타입의 자료구조의 차이를 설명할 수 있나요?
      - Generic Type은 클래스 선언시 담을 변수들의 타입을 지정해주는 방법. 
      - Generic은 정의된 유형의 데이터만 보유할수 있고, 안전하지만, 비제네릭은 모든데이터를 보유할 수 있지만, 안전하지 않습니다.
      - 제네릭은 타입 캐스팅이 필요 없고, 비제네릭은 검색할때마다 개별 유형 캐스팅을 수행해야 합니다.
      - 비제네릭은 런타임시 안정성 확인, 제네릭은 컴파일타임에 형식 안정성을 확인할 수 있습니다.

   참조 사이트 : http://dawoonjeong.com/java-generic-vs-non-generic/

   None Generic 타입의 자료구조는 종류는 무엇이 있나요?
      - 기본형 자료형 타입
      
   Generic 타입의 자료구조는 무엇이 있나요?
      - 컬렉션으로 구조이기 때문에 최상위객체인 Object형태로 저장되고 있습니다.

   Generic 타입의 자료구조의 장점은 무엇인가요?
      - 프로그래머가 원하는 객체의 타입을 명시해서 의도하지 않은 객체는 저장될 수 없도록 컴파일시에 오류를 확인할 수 있게 된다.
      
    * Optional 조사하기
   
## 5. final keyword
   final class
   - 다른 클래스에서 상속하지 못한다.
   
   final method
   - 다른 메소드에서 오버라이딩하지 못한다.
   
   final variable
   - 변하지 않는 상수값이 되어 새로 할당할 수 없는 변수가 된다.
   
   finally
   try-catch or try-catch-resource 구문을 사용할 때, 정상적으로 작업을 한 경우와 에러가 발생했을 경우를 포함하여 마무리 해줘야하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록이다.

   finalize()
   keyword 도 아니고 code block 도 아닌 메소드이다. 
   GC에 의해 호출되는 함수로 절대 호출해서는 안 되는 함수이다. 
   Object 클래스에 정의되어 있으며 GC 가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없다. 
   또한 finalize() 메소드가 오버라이딩 되어 있으면 GC 가 이루어질 때 바로 Garbage Collecting 되지 않는다. GC 가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있다.
   

## 6. 오버로딩과 오버라이딩의 차이점
   1. 오버로딩은 메서드 이름들이 같아도 매개변수가 다르게 만들 수있습니다.
   2. 오버라이딩은 상속받은 클래스나 인터페이스의 메소드를 재정의 할수있습니다.

   (2) 오버라이딩시 발생하는 동적바인딩에 대해 설명해주세요
   -   동적바인딩이란 다형성을 사용하여 메소드를 호출할 때 발생하는 현상이다. 런타임에 성격이 결정되며 실제 참조하는 객체는 서브 클래스이니 서브 클래스의 메소드를 호출하게 된다.

   (3) 오버로딩의 정적 바인딩에 대해 설명해주세요.
   -   정적바인딩이란 컴파일 시간에 성격이 결정되는 것을 말한다.

## 7. Access Modifier (접근 제한자)

   - public : 어떤 클래스에서라도 접근이 가능하다.
   - protected : 클래스가 정의되어 있는 해당 패키지 내 그리고 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능하다.
   - private : 정의된 해당 클래스에서만 접근이 가능하도록 접근 범위를 제한한다.
   - friendly ->패키지 가시성 (public이 생략된 클래스 -> friendly 패키지) 

## 8. Wrapper class
   - 기본 자료형에 대한 클래스 표현을 래퍼 클래스라고 합니다. Integer, Float, Boolen등이 래퍼클래스의 예이다.
   
   Wrapper class 를 사용해야 하는 이유는??
   - 객체지향적인 프로그램을 위한 프로그래밍이기 때문에 기본자료형이었으면, == 으로 바로 비교해줄 수있지만, 래퍼클래스 경우에는 .intValue() 메소드를 통해 해당 래퍼 클래스의 값을 가져와 비교해줘야 한다.
   
   boxing, unboxing 무엇인지, 자동으로 언제 일어나는지
   - wrapper class에서 기본형 객체를 wrapper로 바꿔주는 것을 박싱이라고하고, 반대로 primitive로 바꾸는것을 언박싱이라고 한다.

## 9. Multi-Thread 환경에서의 개발
   9-1 Field member
   - 필드란 클래스에 변수를 정의하는 공간을 의미한다. 이곳에 변수를 만들어두면 메소드 끼리 변수를 주고 받는 데 있어서 참조하기 쉬우므로 편리한 공간 중 하나이다.
     하지만 객체가 여러 스레드가 접근하는 싱글톤 객체라면 field에서 상태값을 갖고 있으면 안된다. 모든 변수를 파라미터로 넘겨받고 리턴하는 방식으로 코드를 구성해야 한다.
     
   9-2 동기화 synchronized {}에 붙을때와 메소드에 붙을때 차이 (동기화 메소드와 동기화 블록 차이점??)
   -   참조사이트 : synchronized 키워드의 의미를 알고 메소드와 블록에 붙을 때의 차이를 알아야 한다. 
      (https://opentutorials.org/module/1226/8028) (https://programmers.co.kr/learn/courses/9/lessons/274)

      synchronized 메소드 -> 메서드하나 모두가 실행되고 다음 메서드 대기하고 있다가 실행됩니다. (1,2,3 메서드가 있으면 1번이 끝날때까지 기다리고, 3번은 맨 마지막으로 기다리게됩니다)
      필요한 부분만 동기화를 시키고 싶다면??? synchronized (this){}를 사용하면 됩니다.
   
   9-3 멀티쓰레드 환경에서 동기화를 지원하지 않으면 어떤문제가 발생하나요?   
   -    1. 동기화되지 않은 데이터 접근 :
       -> 병렬적으로 실행 중인 두 스레드가 같은 데이터를 읽고 쓸 때 어떤 명령문이 먼저 실행될 지는 결정되지 않는다.

      2. 쓰다만 데이터 : 
      -> 한 스레드가 데이터를 읽고있고, 다른 스레드는 수정하고 있다면 읽는 스레드는 다른 스레드가 값을 쓰는 중간에 데이터를 읽을 수도 있다.
      이렇게 되면 읽은 데이터는 이전 값도 아니고 그렇다고 새롭게 갱신된 값도 아니게된다.

      3. 순서가 바뀐 명령문 : 
      -> 단일 스레드에서 문제가 없는 동작에 한해서 명령문과 연산의 순서는 바뀔 수 있다. 하지만 멀티 스레드 환경에서 이러한 순서의 재배치는 원치 않은 동작을 하지 않을 수 있다.
   
   9-4 자바에서 쓰레드를 구현하기 위한 2가지 방법을 간단하게 설명하시오.
      Extends Thread
         - 객체 하나당 스레드 하나 일때(경마 게임처럼 동시에 여러개가 움직이는 상황)
      Implements Runnable
         - 객체와 별개의 스레드를 생성할 때(객체는 Runnable 인터페이스를 구현한 상태로만 작업하고, 필요한 만큼 객체를 생성하고 싶을 때 implements Runnable을 추가)
   
   9-5 멀티쓰레드에서 synchronized를 안쓰고 synchronized를 하는방법
      - 독립적인 메모리 공간 프로세스 단위로 관리되는 자원 중 가장 중요한 구별점은 가상 메모리이다. 페이징 기법을 이용하여 프로세스마다 별도의 고유한 메모리를 사용할 수 있게 하고 있다.
   
   
## 10. ThreadLocal
   - 쓰레드의 지역 변수
   - 각 쓰레드마다 쓸 수 있는 자원을 관리해주는 클래스 입니다.
   
   ThreadLocal 주의사항 
   - ThreadLocal을 사용하는 경우 변수에 보관된 데이터 사용이 끝나면 반드시 해당 데이터를 삭제 해주어야한다. 
     그렇지 않을 경우 재사용 되는 쓰레드가 올바르지 않은 데이터를 참조할 수도 있다.
   
   싱글턴 패턴
      - 인스턴스가 1개만 생성되는 특징을 가진 싱글턴 패턴을 이용하면, 
         하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용하게끔 할 수 있으므로, 요청이 많은 곳에서 사용하면 효율을 높일 수 있습니다

* 동기화를 지원하는 자료구조는 어떤것들이 있나요?

* 동기화를 지원하는 자료구조는 왜, 언제 필요할까요?
   - 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제가 필요할 때.

* 알고있는 MAP의 종류는? 
-> HashMap, TreeMap, LinkedHashMap 이 대표적입니다.

* HashTable과 HashMap의 차이는 무엇인가요?
   -> Hashtable은 JDK1.0 번전에서에서 처음 등장합니다. 하지만, JDK1.2 버전이 되면서부터 속도 문제 때문에 HashMap이라는 것으로 대체되었습니다. 
   -> 멀티 스레드 환경에서 안전하게 객체를 추가 삭제할 수 있음.(멀티 스레드 환경이 아니라면 HashMap을 사용)
   Vector와 마찬가지로 멀티스레드에서 안정성을 보장하는 장점이 있지만, 속도가 느리므로 여러분이 실제로 구현할 때 가장 많이 사용할 클래스는 HashMap 클래스입니다.
   -> Hashtable은 키나 null값 저장이 불가하고, HashMap은 가능합니다. 단, 쓰레드 안전여부는 떨어집니다.

* Hashing이란 무엇인가요?
   -> 해시함수를 이용해서 데이터를 해시 테이블에 저장하고 검색하는 기법을 말합니다.
   
* hash란?
   - 내부적으로 배열을 사용하여 데이터를 저장하여 검색 속도가 빠릅니다.
   - 데이터의 삽입/삭제 시 해시 알고리즘을 이용하여 데이터와 연관된 고유한 숫자를 만들어 인덱스로 사용합니다.
   
   * 해시 메서드?
   - 해시는 해시테이블을 사용하여 데이터를 저장한다.
   - 이때 인덱스를 구하기 위해 해시 메서드를 사용하여 고유의 숫자 값인 해시코드를 얻는다.
   
   * 해시메서드 구현방법 ?
   - 나머지 연산자를 이용하여 해시코드를 구한다.

   참조주소 : https://snow-line.tistory.com/94?category=948914
   
* serialVersionUID를 선언해야 하는 이유
   - JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여합니다. 
   SerialVersionUID값을 저장할 때 클래스 버전이 맞는지 확인하기 위한 용도입니다.

* 직렬화와 역직렬화 차이점   
   - 객체 직렬화 : 객체의 내용을 Byte 단위로 변환하여 파일 또는 네트워크를 통해 Stream(송/수신)이 가능하게 하는 것
   - 역직렬화    : Byte로 변환된 Data를 원래대로 Object나 Data로 변환하는 기술

* 다형성
   - 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있어 다양한 결과를 얻어내는 성질입니다.
   
   * 다형성 효과
   - 하나의 타입으로 다양한 실행 결과를 얻을 수 있다.
   - 객체를 부품화하여 유지 보수를 편하게 한다.
   
   * 다형성 성립조건
   - 클래스 계층구조 (상속관계)
   - 메소드 재정의, 동적 바인딩
   - 업케스팅 후 재정의 된 메소드 호출

* 메모리 누수 원인
   - Static 변수에 의한 객체 참조
   - 모든 현재 자바 쓰레드 statck내의 지역변수, 매개 변수에 의한 객체 참조
   - JNI 프로그램에 의해 동적으로 만들어지고 제거되는 JNI global 객체 참조
   -> 이러한 경우에 사용할 수 있는 개체로 분류되어 GC에서 가져가지 안항 메모리가 누수될 수 있습니다.
   
* non-static멤버와 static 멤버의 차이
   1. non-static멤버
   - 멤버는 객체마다 별도로 존재한다.(인스턴스 멤버)
   - 객체 생성 시에 멤버가 생성된다.
   - 공유되지 않는다.
   
   2. static멤버
   - 멤버는 클래스당 하나가 생성된다.(클래스 멤버)
   - 클래스 로딩 시에 멤버가 생성된다.
   - 동일한 클래스의 모든 객체들에 의해 공유된다.
