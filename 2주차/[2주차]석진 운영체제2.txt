(1) 운영체제란?
- 컴퓨터 하드웨어 바로 위에 설치되어, 소프트웨어와 사용자가 하드웨어 사이를 연결하는 소프트웨어 계층.
- 좁은 의미의 운영체제 (커널) : 메모리에 상주하여 하드웨어의 자원을 배분하는 역할
- 넓은 의미의 운영체제 (MS windows) : 커널을 포함한 시스템의 다양한 소프트웨어.


(2) 운영 체제의 주요 목적은 무엇입니까?
- 자원(cpu, memory, I/O device 등)을 효율적으로 사용하기 위하여
- 하드웨어를 사용함에 있어서 운영체제에게 그 업무를 대체하여 개발자와 사용자에게 편의성 제공

(3) 프로세스란?
- 프로세스란 프로그램이 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 의미한다. 

(4) 프로세스의 특징을 설명하세요.

(5) 스레드는 무엇입니까?
- 스레드는 프로세스의 실행 단위이다. 
- 한 프로세스에는 최소한 하나의 스레드가 존재한다. 
- 한 프로세스에 다수의 스레드가 존재할 수 있으며, 스레드들은 한 프로세스의 자원을 공유한다.

(6) 스레드의 특징을 설명하세요
- 각 각의 스레드는 cpu를 점유하기 위하여 각자의 Program counter와 register를 할당 받는다. 그 값은 스레드가 소속된 프로세서의 PCB에 저장되어 있다. 
- 각 각의 스레드는 처리한 결과 값을 보존하기 위하여, 프로세서의 주소공간 중 stack에 각 각의 영역을 할당 받는다. 

(7) Thread-safe 하다는 의미와 설계하는 법을 설명해보세요.
- 다수의 스레드가 하나의 프로세스의 데이타에 같이 접근하기 때문에 데이타가 원치 않는 방식으로 변경될 수 있다. 이로부터 안전한 것을 Thread-safe라고 한다.
- 상호 배제Mutual Exclusion의 원칙에 따라 설계해야 한다. 

(8) 프로세스와 스레드의 차이점
- 프로세스는 실행 중인 프로그램을 의미한다. 프로세스는 각자의 주소 공간을 배정받는다. 프로세스는 원칙적으로 서로의 메모리에 접근할 수 없다. 
- 스레드는 cpu 사용의 기본 단위이다. 하나의 프로세스에는 하나의 이상의 스레드가 존재할 수 있다. 하나의 프로세스에 존재하는 다수의 스레드는 프로세스의 자원을 공유한다. 

(9) 스레드의 장점과 단점에 대해 설명해 주세요
- 응답성 Responsiveness : 하나의 쓰레드가 blocked 되어도 다른 쓰레드가 작동 가능.
- 자원의 공유 Resource Sharing : 여러개의 쓰레드가 하나의 프로세스의 자원을 공유함.
- 경제성 Economy : 여러 개의 프로세서를 생성하고 Context Swich를 하는 것보다 쓰레드를 여러 개를 가지는 것이 훨씬 오버헤드를 방지.
- 멀티 프로세서 cpu에서의 장점 : 멀티 프로세서 cpu의 경우 각각의 쓰레드가 병렬적으로 사용하여 자원을 효과적으로 사용.

(10) 멀티 스레딩의 장점

(11) 멀티 스레딩의 문제점

(12) 멀티 스레드 vs 멀티 프로세스
- 프로세스는 실행 중인 프로그램을 의미한다. 프로세스는 각자의 주소 공간을 배정받는다. 프로세스는 원칙적으로 서로의 메모리에 접근할 수 없다. 
- 스레드는 cpu 사용의 기본 단위이다. 하나의 프로세스에는 하나의 이상의 스레드가 존재할 수 있다. 하나의 프로세스에 존재하는 다수의 스레드는 프로세스의 자원을 공유한다. 

(13) 멀티 프로세싱과 멀티프로그래밍의 차이는?
- Multitasking : 다중 작업
	-> MultiProcessing : 다중의 cpu
	-> MultiProgramming : 다중의 프로그램이 메모리에 로딩 되어 있음
	-> Time sharing : 다중의 프로세스가 CPU를 나눠 씀. 

(14) 소켓이란 무엇입니까?

(15) 커널이란 무엇입니까?
- 메모리에 상주하여 하드웨어의 자원을 배분하는 역할

(16) 힙 영역과 스택영역의 차이점을 설명하시오.

(17) 운영 체제에서 페이징을 사용하는 것은 무엇입니까?

(18) 멀티 프로세서 시스템의 장점은 무엇입니까?

(19) 가상 메모리(Virtual Memory)란 무엇입니까?

(20) 교착 상태(DeadLock)이란?
- 프로세스들이 서로가 가진 자원을 기다리며 block 된 상태.
- 프로세스가 자원을 배출release 하는 시점은, 자신이 가진 자원use과 필요로한 자원request을 동시에 소유하고 그 작업을 완료할 때임.
- 그러므로 자원의 분배allocate의 방식이 중요한 쟁점임.
- 프로세스가 자원을 사용하는 절차 : request-allocate-use-release

(21) 교착상태(데드락)의 발생 4가지 조건
- 상호배제 Mutual exclusion 자원을 하나의 프로세스만 사용
- 비선점 No preemption 자원을 가지면 빼앗기지 않음
- 보유대기 Hold and wait 자신의 자원을 포기하지 않고 타인이 자원을 release하기를 기다림
- 순환대기 circular wait 서로가 서로의 자원을 기다리는 사이클 형성

(22) 교착상태(데드락)와 기아상태의 해결방법에 대해 설명해보세요.
- Deadlock Prevention 앞서의 4가지 조건을 방어
- Deadlock Avoidance 데드락을 회피. 뱅커스 알고리즘 등을 통해 데드락 발생 조건을 예측하고 그 상황 자체를 만들지 않음.
- Deadlock Dectection and Recovery 데드락의 발생을 허용 하되, 뱅커스 알고리즘 등을 사용해서 데드락 발생을 검출하고 고치는 방식
- Deadlock Ignorance 데드락의 해결을 포기함. 데드락 발생을 사용자가 종료 하여 직접 해결을 유도.

(23) Banker's algorithm 은 무엇입니까?
- 데드락의 해결 방법 중 하나인 Deadlock avoidance와 Dectection and Recovery에 사용하는 알고리즘이다. 자원을 각 프로세스마다 허용된 자원Allocation, 최대 요구치Max, 필요Need, 가용자원Available로 분류하여 데드락을 예측하거나 검출할 때 사용한다. 

(24) RAID 란 무엇입니까? RAID의 종류에 대해 말하시오.

(25) 동기(Sync)와 비동기(Async)의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명해보세요.
- 프로세스 내부에서 I/O의 입력 혹은 출력 값이 존재해야만 다음 작업을 진행할 수 있는 것이 동기식 입출력 방식이다. I/O 입력 혹은 출력을 요청했지만, 해당 결과를 확인하지 않고 계속 작업을 진행할 수 있는 것이 비동기식 입출력이다.

(26) 프로세스 제어 블록(Process Control Block, PCB)
- 운영체제(커널)의 자료구조로서 프로세서에 대한 정보를 저장하고 있다. 
- Context switch 문맥 전환에 사용한다. CPU의 할당 과정에서 프로세서가 변경될 때 기존의 프로세스의 값을 PCB와 Kernel Stack에 저장하고, 새로운 프로세서의 pcb와 스택 값을 cache에 호출한다. 

(27) 스풀링이란 무엇입니까?

(28) 뮤텍스란 무엇입니까?
- 상호배제 Mutual Exclusion을 해결하기 위해 사용한다. 0과 1만을 가지며 뮤텍스를 소유(lock/unlock)한 프로세스만 독점적으로 자원에 접근 가능하다.

(29) 뮤텍스와 세마포어의 차이점은 무엇인가요?
- 세마포는 상호 배제를 해결하기 위한 일종의 추상형 자료구조 이다. 세마포를 통하여 Bounded-Buffer Problem(다수의 사용자와 다수의 다수의 자원), Readers - Writer Problem(하나의 생산자와 다수의 소비자), 철학자의 식사(기아 문제)를 해결하는 방법으로 사용한다. 

(30) 운영 체제에서 기아(Starvation) 란 무엇입니까?
- 어떤 프로세스가 그것의 우선권, queue에 도착한 순서, 작업의 길이, 데드락 등 다양한 이유로 원하는 자원을 사용하지 못하는 상태. 

(31) 운영 체제에서 에이징(Aging)는 무엇입니까?
- 기아를 해결하기 위한 하나의 방법이다. 시간이 지날수록 자원 접근에 대한 우선권을 부여한다. 

(32) 운영 체제에서 페이징(Paging)은 무엇입니까?

(33) 페이징의 장점과 단점은?

(34) 세그먼테이션(Segmentation) 이란?

(35) 멀티 스레드 프로그래밍의 장점은 무엇입니까?

(36) 멀티 스레드 프로그래밍의 단점은 무엇입니까?



(37) Scheduling 이란(Process Scheduling)?
- 커널이 cpu의 자원을 효율적으로 사용하기 위한 루틴. 

(38) CPU Scheduling?

(39) CPU 스케줄링은 언제 발생하는가?
- ready queue에 있는 프로세스가 있을 때. 어떤 순서로 프로세스를 cpu에 점유running시킬지 판단이 필요할 때. 

(40) CPU 스케줄링의 종류를 설명하시오.
(50) 스케줄러 종류에 대해 설명해주세요
(51) 장기 스케줄러와 단기 스케줄러의 가장 큰 차이점은??
(52) CPU 스케줄러에 대해 설명해 주세요.
- 장기스케줄러 : 한정된 메모리에 어떤 프로세서를 ready queue로 보낼지 결정하는 역할.
- 중기스케줄러 : 한정된 메모리에 어떤 프로세서를 swap out 할지 결정하는 역할. 
- 단기스케줄러 : ready queue에 있는 프로세서를  cpu에 할당(running)하는 역할. 

(41) 선점 스케줄링과 비선점 스케줄링의 차이점?
- 선점 Preemtion 스케줄링은 프로세스의 문맥교환이 가능한 상태이다.
- 비선점 Non preemtion 스케줄링은 문맥교환이 불가능한 상태이다. 

(42) 메모리 단편화 란 무엇인가?

(43) 내부단편화와 내부단편화란?

(44) 메모리 단편화 해결방법은?

(45) 문맥교환(Context Switching)이란?
(49) 컨텍스트 스위칭에 대해 설명해보세요.
- Context switch 문맥 교환이란 cpu를 점유하는 프로세스를 정지시키고 다른 프로세스를 작동시키는 것을 의미한다. 
- CPU의 할당 과정에서 프로세서가 변경될 때 기존의 프로세스의 값을 PCB와 Kernel Stack에 저장하고, 새로운 프로세서의 pcb와 스택 값을 cache에 호출한다. 

(46) 커널 수준 스레드와 사용자 수준 스레드의 각각 장단점?
(47) 사용자 수준 스레드와 커널 수준 스레드 차이는?
(48) 모드 스위치와 프로세스 스위치 간의 차이점은?
- 사용자 수준 스레드는 자신의 주소 공간에 있는 데이타만에 접근할 수 있다. 
- 커널 수준 스레드는 I/O디바이스에 접근 가능하다. 
- 사용자 프로세스가 항상 보안상 안전하다고 보장할 수 없음. 그러므로 사용자 프로세스가 cpu 점유, 자신의 주소 공간의 데이타 접근 이외의 것을 엄격하게 제한. 
- cpu의 하드웨어 중 하나인 mode bit은 0과 1을 가지며, 0은 커널 모드, 1은 유저모드를 뜻한다. 


(53) 임계영역(critical section)이란?
- 두 개 이상의 프로세스가 공통으로 접근하는 자원 혹은 데이타. 
- 특히 문맥교환과 rollback 되지 않은 PCB로 인한 문제가 중요한 쟁점이다. 

(54) 임계 구역문제를 해결하기 위한 조건이 어떻게 될까요?
- 상호배제 Mutual Exclusion : 가장 중요한 조건으로서 임계 지역에 접근할 때는 하나의 프로세스만 접근할 수 있도록 해야함. 
- 진행 Progress : 상호배제를 엄격한 방식으로 지킬 경우, 임계 지역을 접근하기 위한 조건이 너무 많아져서, 데드락 현상이 발생할 수 있음. 그러므로 상호배제는 제한하되, 진행을 매끄럽게 할 수 있는 루틴 필요. 
- 유한 대기 Bounded Waiting : 어떤 루틴에 의하여 상호배제를 제한한 가운데 진행되더라도 어떤 프로세스가 루틴의 잘못된 코드로 인해 자원자체에 접근이 안될 수도 있음. 기아 현상에 대한 대책도 필요. 

(55) 스택을 스레드마다 독립적으로 할당하는 이유
- 스레드도 프로세스 처럼 스레드문맥교환이 발생할 수 있음. 차후에 해당 스레드가 cpu를 점유하면 이전 값을 불러와야 하기 때문에. 

(56) PC Register 를 스레드마다 독립적으로 할당하는 이유
- register는 cpu가 처리해야할 코드의 집합임. 문맥교환으로 스레드가 어떤 작업 도중 일을 멈췄다면, 이전의 기록을 남겨놔야지, 이후 cpu를 점유할 때 일을 계속 진행할 수 있음. 

(57) 인터럽트란?
- 프로세스가 cpu의 사용을 멈추게 하는 것.

(58) 인터럽트의 종류?
- 인터럽트를 발생시키는 조건은 아래와 같다.
- Timer
- DMA controller
- I/O 디바이스의 각각의 controller

(59) 인터럽트 이외에 이벤트를 처리하는 방식은?
- 트랩.  문맥교환이 일어나지 않지만 유저모드-커널모드-유저모드의 교환이 일어나는 것.
- PCB 교환 등 오버헤드가 발생하지 않음. 

(60) 인터럽트와 트랩의 차이가 무엇인가?
- 두 개는 모두 유저 모드에서 커널 모드로 변경함을 의미한다. 
- 인터럽트는, 유저 모드(mode bit : 1)에서 프로세스가 cpu를 점유할 때, Timer, I/O, DMA 등으로 인해 커널이 cpu를 점유권한(mode bit : 0)을 가져오는 경우를 의미.
- 트랩은, 프로세스가 I/O 디바이스 값을 필요로 하나 디바에스에 접근 권한이 없으므로, 커널에게 cpu의 권한을 넘기며 작업을 대행하는 것. 

(61) 시스템 콜이란?
- 사용자 모드에서 할 수 없고 커널 모드에서 가능한 작업이 존재. 해당 기능을 사용하기 위해 커널에 cpu의 점유 권한을 넘기고(커널모드) 해당 작업을 처리하는 것. 

(62) 시스템 콜의 예시
- fork() 프로세스 복제, exit()프로세스 제거 wait()프로세스 대기  open()파일 열기 read()파일 읽기 등....

(63) 컴파일러와 인터프리터의 차이가 무엇인가요?
- 컴파일은 모든 코드를 한 번에 원하는 언어로 바꾸는 것이며 인터프리터는 코드를 한 줄씩 읽으며 변환하는 것을 의미한다. 