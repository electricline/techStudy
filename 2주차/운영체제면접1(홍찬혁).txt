프로세스와 스레드의 차이(Process vs Thread)
프로그램(Program) 이란
사전적 의미: 어떤 작업을 위해 실행할 수 있는 파일
프로세스(Process) 란
사전적 의미: 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
운영체제로부터 시스템 자원을 할당받는 작업의 단위
특징
프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.

스레드(Thread) 란
사전적 의미: 프로세스 내에서 실행되는 여러 흐름의 단위
프로세스가 할당받은 자원을 이용하는 실행의 단위
특징
스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

멀티 프로세스 대신 멀티 스레드를 사용하는 이유
자원의 효율성 증대
멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
처리 비용 감소 및 응답 시간 단축
또한 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어든다

CPU 스케줄링
스케줄러란 CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법을 말한다. 그 Queue에는 세 가지가 있다.

Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합
Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합
Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합
스케줄러의 종류 세 가지 :

장기 스케줄러 (잡 스케줄러) : 프로세스가 한꺼번에 많이 올라올 시, 메모리와 디스크 사이에서 메모리에, Ready Queue에 어떤 걸 집어넣을지 결정
단기 스케줄러 (CPU 스케줄러) : CPU와 메모리 사이에서 Ready Queue에 있는 프로세스 중 어떤 것을 CPU 할당을 받게 할지 스케줄링
중기 스케줄러 (Swapper) : 여유공간 부족 시 공간을 만들기 위해 메모리에서 쫓아내어 디스크로 옮김, 동시에 메모리가 많이 올라가는 것을 조절
CPU 스케줄링 방법 :
스케줄링 대상은 Ready Queue에 있는 프로세스 대상이다.

FCFS (First Come First Served) : 먼저 온 녀석이 먼저 스케줄링을 받음. 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐
SJF (Short Job First) : 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당.
SRT (Short Remaining Time) : 현재 프로세스의 수행시간이 끝나는 시간보다 나중에 오는 프로세스의 수행시간 완료 시간이 더 짧다면, 그 즉시 그 프로세스에게 CPU를 할당. 선점형 스케줄링. Starvation과 CPU 수행 시간을 측정할 수 없다는 문제가 있음
우선순위 : 정수로 표현된 우선순위가 더 높은 프로세스에게 할당한다. 선점형 방식과 비선점형 방식으로 나눌 수 있는데, 선점형 방식은 우선순위가 높은 프로세스가 도달하면 그 즉시 그 프로세스에게 CPU를 할당. 비선점형 방식은 Ready Queue의 맨 앞에 그 프로세스를 등록. Starvation과 CPU를 사용못하는 프로세스를 CPU가 무한 대기하는 상태가 있을 수 있음. 오래 기다렸을 경우 우선순위를 높이는 Aging을 통해 해결 가능.
Round Robin : 현대적인 CPU 스케줄링으로, 각 프로세스는 동일한 CPU 할당 시간을 갖게 됨. 할당시간 만료시 ready queue 맨 뒤에 가서 줄섬. CPU의 사용시간이 제각각일 때 효율적. 반응 속도가 빨라지며, 공정한 스케줄링. 주의할 점은 할당하는 시간(time quantum)이 너무 길다면 FCFS와 다를게 없음. 너무 작다면 잦은 컨텍스트 스위칭이 발생.

동기, 비동기, 블로킹, 넌블로킹 차이
동기는 어떤 일에 대한 요청과 응답(혹은 입출력)이 동시에 이루어져야 하는 것
비동기는 어떤 일에 대한 요청과 응답이 동시에 이루어질 필요 없이 따로 이루어지는 것.
블로킹은 어떤 요청에 대한 응답이 올 때까지 대기 하는 것. 즉 동기를 위해서는 블로킹 되어야 함
넌블로킹은 어떤 요청에 대해서 응답을 대기하지 않고 계속 루틴을 수행하는 것. 비동기를 위해서는 넌블로킹 되어야 하지만, 넌블로킹이 비동기는 아니다(포함관계라고 생각하면 될 듯). 예를 들어 넌블로킹이면서, 요청에 대한 응답을 계속해서 요구하는 폴링 방식의 경우, 비동기라 보기는 힘들다. 이벤트 핸들러나 인터럽트를 통해 응답을 받는 것이 비동기 모델.

교착상태(데드락)의 개념과 조건
교착상태(데드락) 란
첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리는 상황을 일컷는다.

교착상태 4가지 조건
상호 배제(mutual exclusion)
한 번에 한 프로세스만 공유 자원을 사용할 수 있다.
들고 기다리기(hold and wait) = 점유대기
공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다
선취(preemption) 불가능 = 비선점
한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.
대기 상태의 사이클(circular wait) = 순환대기
두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.

컨텍스트 스위칭
멀티 프로세스 환경에서 CPU 스케줄러가 인터럽트 발생 시 현재 프로세스의 상태를 PCB에 저장하고, 새로운 프로세스의 상태를 레지스터에 저장하는 것을 말함.
